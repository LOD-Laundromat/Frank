#!/bin/bash


command -v curl >/dev/null 2>&1 || { echo >&2 "Please install curl first"; exit 1; }

##
## First handle arguments
##
# Usage info
show_help() {
cat << EOF
Usage: ${0##*/} [options] [DOC_RESOURCE]
Fetch statements from the LOD Cloud, using data hosted and cleaned by the LOD Laundromat. 
When a LOD Laundromat resource (DOC_RESOURCE) is passed as parameter, statements are fetched from that document.
Otherwise, statements are fetched from the complete LOD Cloud

    -h
        display this help and exit
    -s SUBJECT
    --subject SUBJECT
        Filter statements by SUBJECT
    -p PREDICATE
    --predicate PREDICATE
        Filter statements by PREDICATE
    -o OBJECT
    --object OBJECT
        Filter statements by OBJECT
    -g
    --showGraph
        Return quads, where the named graph is the reference to the LOD Laundromat resource 
        of this particular dataset

EOF
}

sub=
pred=
obj=
showGraph=false
while [ "$#" -gt 0 ]; do
    case $1 in
        -h|-\?|--help)   # Call a "show_help" function to display a synopsis, then exit.
            show_help
            exit
            ;;
        
        ##parse subject
        -s|--subject)
            if [ "$#" -gt 1 ]; then
                sub=$2
                shift 2
                continue
            else
                echo 'ERROR: Must specify a non-empty "--subject SUBJECT" argument.' >&2
                exit 1
            fi
            ;;
        --subject=?*)
            sub=${1#*=} # Delete everything up to "=" and assign the remainder.
            ;;
        --subject=)         # Handle the case of an empty --file=
            echo 'ERROR: Must specify a non-empty "--subject SUBJECT" argument.' >&2
            exit 1
            ;;
            
        ##parse predicate
        -p|--predicate)
            if [ "$#" -gt 1 ]; then
                pred=$2
                shift 2
                continue
            else
                echo 'ERROR: Must specify a non-empty "--predicate PREDICATE" argument.' >&2
                exit 1
            fi
            ;;
        --predicate=?*)
            pred=${1#*=} # Delete everything up to "=" and assign the remainder.
            ;;
        --predicate=)         # Handle the case of an empty --file=
            echo 'ERROR: Must specify a non-empty "--predicate PREDICATE" argument.' >&2
            exit 1
            ;;
            
         ##parse object
        -o|--object)
            if [ "$#" -gt 1 ]; then
                obj=$2
                shift 2
                continue
            else
                echo 'ERROR: Must specify a non-empty "--object OBJECT" argument.' >&2
                exit 1
            fi
            ;;
        --object=?*)
            obj=${1#*=} # Delete everything up to "=" and assign the remainder.
            ;;
        --object=)         # Handle the case of an empty --file=
            echo 'ERROR: Must specify a non-empty "--object OBJECT" argument.' >&2
            exit 1
            ;;
            
            
       
        -g|--showGraph)
            showGraph=true;
            ;;
        --)              # End of all options.
            shift
            break
            ;;
        -?*)
            printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2
            ;;
        *)               # Default case: If no more options then break out of the loop.
            break
    esac

    shift
done



#top25 of prefixes
declare -A prefixes=(["yago"]="http://yago-knowledge.org/resource/" ["rdf"]="http://www.w3.org/1999/02/22-rdf-syntax-ns#" ["foaf"]="http://xmlns.com/foaf/0.1/" ["dbp"]="http://dbpedia.org/property/" ["dc"]="http://purl.org/dc/elements/1.1/" ["owl"]="http://www.w3.org/2002/07/owl#" ["rdfs"]="http://www.w3.org/2000/01/rdf-schema#" ["dbo"]="http://dbpedia.org/ontology/" ["ont"]="http://purl.org/net/ns/ontology-annot#" ["onto"]="http://www.ontotext.com/" ["skos"]="http://www.w3.org/2004/02/skos/core#" ["geo"]="http://www.w3.org/2003/01/geo/wgs84_pos#" ["rss"]="http://purl.org/rss/1.0/" ["gldp"]="http://www.w3.org/ns/people#" ["sioc"]="http://rdfs.org/sioc/ns#" ["fb"]="http://rdf.freebase.com/ns/" ["sc"]="http://purl.org/science/owl/sciencecommons/" ["geonames"]="http://www.geonames.org/ontology#" ["xsd"]="http://www.w3.org/2001/XMLSchema#" ["gr"]="http://purl.org/goodrelations/v1#" ["dcterms"]="http://purl.org/dc/terms/" ["dct"]="http://purl.org/dc/terms/" ["org"]="http://www.w3.org/ns/org#" ["dbpedia"]="http://dbpedia.org/resource/" ["qb"]="http://purl.org/linked-data/cube#" ["dbpprop"]="http://dbpedia.org/property/" ["void"]="http://rdfs.org/ns/void#")

if [ -n "$sub" ]; then
    ns=`echo "$sub"| cut -d':' -f 1`
    if [ -n "${prefixes["$ns"]}" ]; then
        localN=`echo "$sub"| cut -d':' -f 2`
        sub="${prefixes["$ns"]}$localN"
    fi
fi
if [ -n "$pred" ]; then
    ns=`echo "$pred"| cut -d':' -f 1`
    if [ -n "${prefixes["$ns"]}" ]; then
        localN=`echo "$pred"| cut -d':' -f 2`
        pred="${prefixes["$ns"]}$localN"
    fi
fi
if [ -n "$obj" ]; then
    ns=`echo "$obj"| cut -d':' -f 1`
    if [ -n "${prefixes["$ns"]}" ]; then
        localN=`echo "$obj"| cut -d':' -f 2`
        obj="${prefixes["$ns"]}$localN"
    fi
fi


##
## Tricky way of detecting which directory
##
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
dirOfFile="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

frankDocs=
if command -v frankDocuments > /dev/null 2> /dev/null; then
    frankDocs="frankDocuments"
else
    #try to see whether this script exists in the current directory
    DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
    if command -v $DIR/frankDocuments > /dev/null 2> /dev/null; then
        frankDocs=$DIR/frankDocuments
    else
        echo "ERROR: could not detect frankDocuments script. Either add it to your PATH environment variable, or include it next to this script"
        exit 1
    fi 
fi


ldfApi="http://ldf.lodlaundromat.org"

processDoc() {
    #start with a sanity check (simple non-empty check)
    if [ -z "$1" ]; then return; fi
    
    #might need to use this var more often, so generate it once for this particular doc
    quadReplace=$(sed -e 's/[\/&]/\\&/g' <<< "$1")
    
    #extract md5 from resource url
    md5=$(sed 's/.*\/\([a-z0-9]\{32\}\).*/\1/;tx;d;:x' <<< "$1")
    
    if [ -z "$md5" ]; then echo "Not a valid LOD Laundromat document identifier: $1" && exit 1; fi 
    url="$ldfApi/$md5"
    
    #while we have something to send request to, i.e. pagination has not finished yet for this document
    while [ -n "$url" ]; do
        response=$(curl -Gs $url -H "Accept: application/n-quads" --data-urlencode "subject=$sub" --data-urlencode "predicate=$pred" --data-urlencode "object=$obj")
        url=
        while read quad; do
            #skip blank lines
            if [ -z "$quad" ]; then continue; fi
            if echo $quad | grep -qE '#metadata>\s*\.'; then
                if echo $quad | grep -q 'nextPage'; then
                    url=$(echo "$quad" | sed 's/.*nextPage>\s*<\(.*\)>\s*<.*/\1/')
                fi
            else 
                if $showGraph ; then
                    echo "$quad" | sed "s/\(.*\)\.$/\1 <$quadReplace>./"
                else
                    echo $quad;
                fi
            fi
            
        done <<< "$response"
    done;
}

runForDocs=true
if [ "$#" -gt 0 ]; then
    #there are graphs passed as arguments to the script
    for res in "$@"; do processDoc "$res";done
    runForDocs=false
fi
if [ ! -t 0 ]; then
    #something is piped to this program
   while read res ; do processDoc "$res" ; done
   runForDocs=false
fi
if $runForDocs ; then
    #no arguments and nothing piped. Just use the whole lod cloud
    while read res ; do processDoc "$res" ; done < <( $frankDocs -r )
fi

