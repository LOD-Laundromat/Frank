#!/bin/bash


command -v curl >/dev/null 2>&1 || { echo >&2 "Please install curl first"; exit 1; }

##
## First handle arguments
##
# Usage info
show_help() {
cat << EOF
Usage: ${0##*/} [options] [DOC_RESOURCE]
Fetch statements from the LOD Cloud, using data hosted and cleaned by the LOD Laundromat. 
When a LOD Laundromat resource (DOC_RESOURCE) is passed as parameter, statements are fetched from that document.
Otherwise, statements are fetched from the complete LOD Cloud

    -h
        display this help and exit
    -s SUBJECT
    --subject SUBJECT
        Filter statements by SUBJECT
    -p PREDICATE
    --predicate PREDICATE
        Filter statements by PREDICATE
    -o OBJECT
    --object OBJECT
        Filter statements by OBJECT
    -g
    --showGraph
        Return quads, where the named graph is the reference to the LOD Laundromat resource 
        of this particular dataset

EOF
}
  
sub=
pred=
obj=
showGraph=false
while [ "$#" -gt 0 ]; do
    case $1 in
        -h|-\?|--help)   # Call a "show_help" function to display a synopsis, then exit.
            show_help
            exit
            ;;
        
        ##parse subject
        -s|--subject)
            if [ "$#" -gt 1 ]; then
                sub=$2
                shift 2
                continue
            else
                echo 'ERROR: Must specify a non-empty "--subject SUBJECT" argument.' >&2
                exit 1
            fi
            ;;
        --subject=?*)
            sub=${1#*=} # Delete everything up to "=" and assign the remainder.
            ;;
        --subject=)         # Handle the case of an empty --file=
            echo 'ERROR: Must specify a non-empty "--subject SUBJECT" argument.' >&2
            exit 1
            ;;
            
        ##parse predicate
        -p|--predicate)
            if [ "$#" -gt 1 ]; then
                pred=$2
                shift 2
                continue
            else
                echo 'ERROR: Must specify a non-empty "--predicate PREDICATE" argument.' >&2
                exit 1
            fi
            ;;
        --predicate=?*)
            pred=${1#*=} # Delete everything up to "=" and assign the remainder.
            ;;
        --predicate=)         # Handle the case of an empty --file=
            echo 'ERROR: Must specify a non-empty "--predicate PREDICATE" argument.' >&2
            exit 1
            ;;
            
         ##parse object
        -o|--object)
            if [ "$#" -gt 1 ]; then
                obj=$2
                shift 2
                continue
            else
                echo 'ERROR: Must specify a non-empty "--object OBJECT" argument.' >&2
                exit 1
            fi
            ;;
        --object=?*)
            obj=${1#*=} # Delete everything up to "=" and assign the remainder.
            ;;
        --object=)         # Handle the case of an empty --file=
            echo 'ERROR: Must specify a non-empty "--object OBJECT" argument.' >&2
            exit 1
            ;;
            
            
       
        -g|--showGraph)
            showGraph=true;
            ;;
        --)              # End of all options.
            shift
            break
            ;;
        -?*)
            printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2
            ;;
        *)               # Default case: If no more options then break out of the loop.
            break
    esac

    shift
done

##
## Tricky way of detecting which directory
##
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
dirOfFile="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

frankDocs=
if command -v frankDocuments > /dev/null 2> /dev/null; then
    frankDocs="frankDocuments"
else
    #try to see whether this script exists in the current directory
    DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
    if command -v $DIR/frankDocuments > /dev/null 2> /dev/null; then
        frankDocs=$DIR/frankDocuments
    else
        echo "ERROR: could not detect frankDocuments script. Either add it to your PATH environment variable, or include it next to this script"
        exit 1
    fi 
fi



ldfApi="http://ldf.lodlaundromat.org"
while read doc; do 
    quadReplace=$(echo "$doc" | sed -e 's/[\/&]/\\&/g')
    md5=$(echo "$doc" | sed 's/.*\/\([a-z0-9]\{32\}\).*/\1/')
    url="$ldfApi/$md5"
    
    #while we have something to send request to, i.e. pagination has not finished yet for this document
    while [ -n "$url" ]; do
        response=$(curl -Gs $url -H "Accept: application/n-quads" --data-urlencode "subject=$sub" --data-urlencode "predicate=$pred" --data-urlencode "object=$obj")
        url=
        while read quad; do
            if echo $quad | grep -qE '#metadata>\s*\.'; then
                if echo $quad | grep -q 'nextPage'; then
                    url=$(echo "$quad" | sed 's/.*nextPage>\s*<\(.*\)>\s*<.*/\1/')
                fi
            else 
                if $showGraph ; then
                    echo "$quad" | sed "s/\(.*\)\.$/\1 <$quadReplace>./"
                else
                    echo $quad;
                fi
            fi
            
        done <<< "$response"
    done;
done < <( if [ "$#" -gt 0 ]; then for res in "$@"; do echo "$res";done else $frankDocs -r; fi )

